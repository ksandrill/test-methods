package org.nsu.fit.services.rest;

import com.github.javafaker.Faker;
import org.glassfish.jersey.client.ClientConfig;
import org.nsu.fit.services.log.Logger;
import org.nsu.fit.services.rest.data.*;
import org.nsu.fit.shared.JsonMapper;

import javax.ws.rs.client.*;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import java.util.*;
import java.util.stream.Collectors;

public class RestClient {
    // Note: change url if you want to use the docker compose.
    private static final String REST_URI = "http://localhost:8080/tm-backend/rest";
    //private static final String REST_URI = "http://localhost:8089/tm-backend/rest";

    private final static Client client = ClientBuilder.newClient(new ClientConfig().register(RestClientLogFilter.class));

    public AccountTokenPojo authenticate(String login, String pass) {
        CredentialsPojo credentialsPojo = new CredentialsPojo();

        credentialsPojo.login = login;
        credentialsPojo.pass = pass;

        return post("authenticate", JsonMapper.toJson(credentialsPojo, true), AccountTokenPojo.class, null);
    }

    public CustomerPojo createAutoGeneratedCustomer(AccountTokenPojo accountToken) {
        ContactPojo contactPojo = new ContactPojo();

        // Лабораторная 3: Добавить обработку генерацию фейковых имен, фамилий и логинов.
        // * Исследовать этот вопрос более детально, возможно прикрутить специальную библиотеку для генерации фейковых данных.
        Faker faker = new Faker();
        contactPojo.firstName = faker.name().firstName();
        contactPojo.lastName = faker.name().lastName();
        contactPojo.login = faker.internet().emailAddress();
        contactPojo.pass = faker.internet().password(7, 11);

        return post("customers", JsonMapper.toJson(contactPojo, true), CustomerPojo.class, accountToken);
    }


    private static <R> R post(String path, String body, Class<R> responseType, AccountTokenPojo accountToken) {
        // Лабораторная 3: Добавить обработку Responses и Errors. Выводите их в лог.
        // Подумайте почему в filter нет Response чтобы можно было удобно его сохранить.

        Logger.debug("Send POST request to " + path);
        Logger.debug("POST request body: " + body);

        Invocation.Builder request = client
                .target(REST_URI)
                .path(path)
                .request(MediaType.APPLICATION_JSON)
                .accept(MediaType.APPLICATION_JSON);

        if (accountToken != null) {
            request.header("Authorization", "Bearer " + accountToken.token);
        }

        Response response = request.post(Entity.entity(body, MediaType.APPLICATION_JSON), Response.class);

        if (response.getStatus() != 200) {
            Logger.debug("Response status: " + response.getStatus() + " \nReason:" + response.getStatusInfo().getReasonPhrase());
            return null;
        }

        Logger.debug("Response status: " + response.getStatus());

        if (!response.hasEntity()) {
            Logger.debug("Empty response body");
            return null;
        }

        String responseBody = response.readEntity(String.class);
        Logger.debug("Response body: " + responseBody);
        return JsonMapper.fromJson(responseBody, responseType);
    }

    private static <R> R get(String path, String body, Class<R> responseType, AccountTokenPojo accountToken, Map<String, String> queryParams) {
        Logger.debug("Send GET request to " + path);
        Logger.debug("GET request body: " + body);

        WebTarget webTarget = client.target(REST_URI).path(path);

        if (queryParams != null) {
            for (Map.Entry<String, String> entry : queryParams.entrySet()) {
                webTarget.queryParam(entry.getKey(), entry.getValue());
            }
        }

        Invocation.Builder request = webTarget
                .request(MediaType.APPLICATION_JSON)
                .accept(MediaType.APPLICATION_JSON);

        if (accountToken != null) {
            request.header("Authorization", "Bearer " + accountToken.token);
        }

        Response response = request.get(Response.class);

        if (response.getStatus() != 200) {
            Logger.debug("Response status: " + response.getStatus() + " \nReason:" + response.getStatusInfo().getReasonPhrase());
            return null;
        }

        Logger.debug("Response status: " + response.getStatus());

        if (!response.hasEntity()) {
            Logger.debug("Empty response body");
            return null;
        }

        String responseBody = response.readEntity(String.class);
        Logger.debug("Response body: " + responseBody);
        return JsonMapper.fromJson(responseBody, responseType);
    }

    private static <R> R delete(String path, String body, Class<R> responseType, AccountTokenPojo accountToken) {
        Logger.debug("Send DELETE request to " + path);
        Logger.debug("DELETE request body: " + body);

        Invocation.Builder request = client
                .target(REST_URI)
                .path(path)
                .request(MediaType.APPLICATION_JSON)
                .accept(MediaType.APPLICATION_JSON);

        if (accountToken != null) {
            request.header("Authorization", "Bearer " + accountToken.token);
        }

        Response response = request.delete(Response.class);

        if (response.getStatus() != 200) {
            Logger.debug("Response status: " + response.getStatus() + " \nReason:" + response.getStatusInfo().getReasonPhrase());
            return null;
        }

        Logger.debug("Response status: " + response.getStatus());

        if (!response.hasEntity()) {
            Logger.debug("Empty response body");
            return null;
        }

        String responseBody = response.readEntity(String.class);
        Logger.debug("Response body: " + responseBody);
        return JsonMapper.fromJson(responseBody, responseType);
    }

    public void deleteCustomer(CustomerPojo customerPojo, AccountTokenPojo adminToken) {
        delete("customers/" + customerPojo.id, "", void.class, adminToken);
    }

    public ContactPojo meAdmin(AccountTokenPojo accountToken) {
        return get("me", "", ContactPojo.class, accountToken, null);
    }

    public CustomerPojo meCustomer(AccountTokenPojo accountToken) {
        return get("me", "", CustomerPojo.class, accountToken, null);
    }

    public CustomerPojo createCustomer(CustomerPojo customerPojo, AccountTokenPojo adminToken) {
        return post("customers", JsonMapper.toJson(customerPojo, true), CustomerPojo.class, adminToken);
    }


    public List<CustomerPojo> getCustomers(AccountTokenPojo adminToken, String customerLogin) {
        Map<String, String> queryParams = new HashMap<>();
        queryParams.put("login", customerLogin);

        return Arrays.stream(
                Objects.requireNonNull(
                        get("customers", "", CustomerPojo[].class, adminToken, queryParams)
                )
        ).collect(
                Collectors.toList()
        );
    }

    public void topUpBalance(AccountTokenPojo accountTokenPojo, TopUpBalanceRequest topUpBalanceRequest) {
        post("customers/top_up_balance", JsonMapper.toJson(topUpBalanceRequest, true), void.class, accountTokenPojo);
    }


    private static class RestClientLogFilter implements ClientRequestFilter {
        @Override
        public void filter(ClientRequestContext requestContext) {
            if (requestContext.hasEntity()) {
                Logger.debug(requestContext.getEntity().toString());
            }
            // Лабораторная 3: разобраться как работает данный фильтр
            // и добавить логирование METHOD и HEADERS.
            Logger.debug("METHOD: " + requestContext.getMethod());
            Logger.debug("HEADERS: " + requestContext.getHeaders());
        }
    }
}
